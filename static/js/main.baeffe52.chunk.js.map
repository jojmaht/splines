{"version":3,"sources":["positionUtils.js","regularPolygonEngine.js","starPolygonEngine.js","SplineLayer.jsx","App.js","index.js"],"names":["getPositionOffsets","position","offsetX","offsetY","getRegularPolygonPoints","radius","shape","layerDimensions","rotation","precisePosition","x","y","quickPosition","points","numPoints","angleStep","Math","PI","additionnalOffsetX","additionnalOffsetY","i","theta","cos","sin","push","getPointsFromSchlafli","p","q","indices","starPolygonIndices","console","log","getStarPolygonPoints","max","min","pointIndices","SplineLayer","index","exportPaths","layerLabel","properties","useControls","folder","type","options","isFilled","color","tension","value","step","thickness","nested","useNestedParams","render","get","nestedParams","nShape","nType","nIsFilled","nColor","nTension","nRadius","nThickness","nRotation","hideMainSpline","getPointsGetter","mainPath","path","spline","nestedPaths","map","point","nestedRadius","nestedRotation","nestedShape","nestedTension","nestedThickness","nestedColor","nestedIsFilled","nestedPoints","flat","items","useEffect","paths","zIndex","stroke","strokeWidth","sceneFunc","context","Path2D","fillStrokeShape","_context","lineWidth","strokeStyle","fillStyle","fill","ExportSVG","numberOfLayers","backgroundColor","useState","hover","setHover","serializedSVG","encodeURIComponent","Object","keys","slice","key","href","onMouseEnter","onMouseLeave","download","style","padding","width","margin","background","borderRadius","fontFamily","fontSize","textDecoration","display","textAlign","transition","App","layers","childrenPaths","setChildrenPaths","className","height","overflow","inset","Array","from","length","item","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.baeffe52.chunk.js","sourcesContent":["export const getPositionOffsets = (position) => {\n  switch (position) {\n    case \"center\":\n      return { offsetX: 0, offsetY: 0 };\n    case \"top-left\":\n      return { offsetX: -500, offsetY: -500 };\n    case \"top-center\":\n      return { offsetX: 0, offsetY: -500 };\n    case \"top-right\":\n      return { offsetX: 500, offsetY: -500 };\n    case \"middle-left\":\n      return { offsetX: -500, offsetY: 0 };\n    case \"middle-right\":\n      return { offsetX: 500, offsetY: 0 };\n    case \"bottom-left\":\n      return { offsetX: -500, offsetY: 500 };\n    case \"bottom-center\":\n      return { offsetX: 0, offsetY: 500 };\n    case \"bottom-right\":\n      return { offsetX: 500, offsetY: 500 };\n    default:\n      return {\n        offsetX: 0,\n        offsetY: 0,\n      };\n  }\n};\n","import { getPositionOffsets } from \"./positionUtils\";\n\nexport const getRegularPolygonPoints = (\n  radius,\n  shape,\n  layerDimensions,\n  rotation,\n  precisePosition = { x: 0, y: 0 },\n  quickPosition = \"center\"\n) => {\n  const points = [];\n  const numPoints = shape === 0 ? 12 : shape;\n  const angleStep = (Math.PI * 2) / numPoints;\n  const { offsetX, offsetY } = getPositionOffsets(quickPosition);\n  const { x: additionnalOffsetX, y: additionnalOffsetY } = precisePosition;\n\n  for (let i = 1; i <= numPoints; i++) {\n    const theta = i * angleStep + Math.PI * 2 * ((rotation - 90) / 360);\n\n    const x = Math.cos(theta) * radius;\n    const y = Math.sin(theta) * radius;\n\n    points.push(\n      ...[\n        {\n          x: layerDimensions / 2 + offsetX + additionnalOffsetX + x,\n          y: layerDimensions / 2 + offsetY + additionnalOffsetY + y,\n          theta,\n        },\n      ]\n    );\n  }\n\n  return points;\n};\n","import { getPositionOffsets } from \"./positionUtils\";\n\nconst getPointsFromSchlafli = ([p, q]) => {\n  const indices = [0];\n  for (let i = 1; i <= p; i++) {\n    indices.push((q * i) % p);\n  }\n  return indices;\n};\n\nconst starPolygonIndices = {\n  3: [0, 1, 2, 0],\n  4: [0, 2, 3, 1, 0],\n  5: getPointsFromSchlafli([5, 2]),\n  6: [0, 2, 5, 3, 1, 4, 0],\n  7: getPointsFromSchlafli([7, 3]),\n  8: getPointsFromSchlafli([8, 3]),\n  9: getPointsFromSchlafli([9, 2]),\n  10: getPointsFromSchlafli([10, 3]),\n  11: getPointsFromSchlafli([11, 3]),\n  12: getPointsFromSchlafli([12, 5]),\n  13: getPointsFromSchlafli([13, 3]),\n};\n\nconsole.log(starPolygonIndices);\n\nexport const getStarPolygonPoints = (\n  radius,\n  shape,\n  layerDimensions,\n  rotation,\n  precisePosition = { x: 0, y: 0 },\n  quickPosition = \"center\"\n) => {\n  const points = [];\n  const numPoints = Math.max(3, Math.min(shape, 13));\n  const angleStep = (Math.PI * 2) / numPoints;\n  const { offsetX, offsetY } = getPositionOffsets(quickPosition);\n  const { x: additionnalOffsetX, y: additionnalOffsetY } = precisePosition;\n\n  const pointIndices = starPolygonIndices[numPoints]\n    ? starPolygonIndices[numPoints]\n    : getPointsFromSchlafli([numPoints, 3]);\n\n  for (let i = 1; i <= numPoints; i++) {\n    const theta =\n      angleStep * pointIndices[i] + Math.PI * 2 * ((rotation - 90) / 360);\n\n    const x = Math.cos(theta) * radius;\n    const y = Math.sin(theta) * radius;\n\n    points.push(\n      ...[\n        {\n          x: layerDimensions / 2 + offsetX + additionnalOffsetX + x,\n          y: layerDimensions / 2 + offsetY + additionnalOffsetY + y,\n          theta,\n        },\n      ]\n    );\n  }\n\n  return points;\n};\n","import { useEffect } from \"react\";\nimport { Group, Shape } from \"react-konva\";\nimport { useControls, folder } from \"leva\";\nimport { spline } from \"@georgedoescode/spline\";\n\nimport { getRegularPolygonPoints } from \"./regularPolygonEngine\";\nimport { getStarPolygonPoints } from \"./starPolygonEngine\";\n\nexport const SplineLayer = ({ index, exportPaths }) => {\n  const layerLabel = `Layer ${index}`;\n  const properties = useControls({\n    [layerLabel]: folder({\n      type: {\n        options: [\"polygon\", \"star\"],\n      },\n      shape: 4,\n      isFilled: false,\n      color: \"#fff\",\n      tension: 0,\n      radius: { value: 200, min: 0, max: 500, step: 1 },\n      thickness: 1,\n      rotation: { value: 0, min: -360, max: 360, step: 0.5 },\n      quickPosition: {\n        options: [\n          \"center\",\n          \"top-left\",\n          \"top-center\",\n          \"top-right\",\n          \"middle-left\",\n          \"middle-right\",\n          \"bottom-left\",\n          \"bottom-center\",\n          \"bottom-right\",\n        ],\n      },\n      precisePosition: { value: { x: 0, y: 0 }, step: 20 },\n      nested: false,\n      useNestedParams: {\n        value: false,\n        render: (get) => get(`${layerLabel}.nested`),\n      },\n      nestedParams: folder(\n        {\n          nShape: 3,\n          nType: {\n            options: [\"polygon\", \"star\"],\n          },\n          nIsFilled: false,\n          nColor: \"#ffffff\",\n          nTension: 0,\n          nRadius: { value: 50, min: 0, max: 500, step: 1 },\n          nThickness: { value: 1, min: 0, step: 1 },\n          nRotation: { value: 0, min: -360, max: 360, step: 0.5 },\n        },\n        {\n          render: (get) => get(`${layerLabel}.useNestedParams`),\n        }\n      ),\n      hideMainSpline: {\n        value: false,\n        render: (get) => get(`${layerLabel}.nested`),\n      },\n    }),\n  });\n\n  const {\n    type,\n    shape,\n    isFilled,\n    color,\n    tension,\n    radius,\n    nested,\n    nColor,\n    nTension,\n    nIsFilled,\n    nType,\n    nShape,\n    nRadius,\n    nThickness,\n    nRotation,\n    useNestedParams,\n    hideMainSpline,\n    thickness,\n    quickPosition,\n    precisePosition,\n    rotation,\n  } = properties;\n\n  const width = 1000;\n\n  const getPointsGetter = (type) => {\n    if (type === \"star\") {\n      return getStarPolygonPoints;\n    } else return getRegularPolygonPoints;\n  };\n\n  const points = getPointsGetter(type)(\n    radius,\n    shape,\n    width,\n    rotation,\n    precisePosition,\n    quickPosition\n  );\n\n  const mainPath = !hideMainSpline\n    ? { path: spline(points, tension, true), color, thickness, isFilled }\n    : [];\n\n  const nestedPaths = nested\n    ? points\n        .map((point) => {\n          const nestedType = useNestedParams ? nType : type;\n          const nestedRadius = useNestedParams ? nRadius : radius / 2;\n          const nestedRotation = useNestedParams ? nRotation : rotation / 4;\n          const nestedShape = useNestedParams ? nShape : shape;\n          const nestedTension = useNestedParams ? nTension : tension;\n          const nestedThickness = useNestedParams ? nThickness : thickness;\n          const nestedColor = useNestedParams ? nColor : color;\n          const nestedIsFilled = useNestedParams ? nIsFilled : isFilled;\n\n          const nestedPoints = getPointsGetter(nestedType)(\n            nestedRadius,\n            nestedShape,\n            0,\n            nestedRotation,\n            point\n          );\n\n          return [\n            {\n              path: spline(nestedPoints, nestedTension, true),\n              color: nestedColor,\n              thickness: nestedThickness,\n              isFilled: nestedIsFilled,\n            },\n          ].flat();\n        })\n        .flat()\n    : [];\n\n  const items = [mainPath, ...nestedPaths];\n\n  useEffect(() => {\n    exportPaths((paths) => ({ ...paths, ...{ [index]: items } }));\n  }, [properties]);\n\n  return (\n    <Group zIndex={index}>\n      {items.map(({ path, color, thickness, isFilled }) => (\n        <Shape\n          stroke={color}\n          strokeWidth={thickness}\n          x={0}\n          y={0}\n          sceneFunc={(context, shape) => {\n            const p = new Path2D(path);\n            context.fillStrokeShape(shape);\n            context._context.lineWidth = thickness;\n            context._context.strokeStyle = color;\n            context._context.fillStyle = isFilled ? color : \"transparent\";\n            context._context.fill(p);\n            context._context.stroke(p);\n          }}\n        ></Shape>\n      ))}\n    </Group>\n  );\n};\n","import \"./App.css\";\nimport { useState } from \"react\";\nimport { Layer, Stage, Rect } from \"react-konva\";\nimport { SplineLayer } from \"./SplineLayer\";\nimport { useControls } from \"leva\";\n\nfunction App() {\n  const { layers, backgroundColor } = useControls({\n    layers: 1,\n    backgroundColor: \"#000000\",\n  });\n\n  const [childrenPaths, setChildrenPaths] = useState({});\n\n  return (\n    <div className=\"App\" style={{ display: \"flex\" }}>\n      <div\n        style={{\n          width: \"100vh\",\n          height: \"100vh\",\n          position: \"relative\",\n          overflow: \"hidden\",\n        }}\n      >\n        <Stage\n          width={1000}\n          height={1000}\n          style={{ position: \"absolute\", inset: 0 }}\n        >\n          <Layer>\n            <Rect\n              x={0}\n              y={0}\n              width={1000}\n              height={1000}\n              fill={backgroundColor}\n              sceneFunc={(context, shape) => {\n                const p = new Path2D(\"M0,0L1000,0L1000,1000L0,1000Z\");\n                context.fillStrokeShape(shape);\n                context._context.lineWidth = 0;\n                context._context.fill(p);\n              }}\n            />\n            {Array.from({ length: layers }).map((item, index) => (\n              <SplineLayer\n                index={index}\n                exportPaths={(path) => setChildrenPaths(path)}\n              />\n            ))}\n          </Layer>\n        </Stage>\n      </div>\n      <div>\n        <ExportSVG\n          paths={childrenPaths}\n          numberOfLayers={layers}\n          backgroundColor={backgroundColor}\n        />\n      </div>\n    </div>\n  );\n}\n\nconst ExportSVG = ({ paths, numberOfLayers, backgroundColor }) => {\n  const [hover, setHover] = useState(false);\n\n  const serializedSVG =\n    \"data:image/svg+xml;charset=utf-8,\" +\n    encodeURIComponent(\n      `<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"1000\" height=\"1000\" viewBox=\"0 0 1000 1000\"><rect x=\"0\" y=\"0\" width=\"1000\" height=\"1000\" fill=\"${backgroundColor}\"/>${[\n        ...Object.keys(paths),\n      ]\n        .slice(0, numberOfLayers)\n        .map((key) => paths[key])\n        .flat()\n        .map(({ path, thickness, color, isFilled }) => {\n          return `<path\n        d=\"${path}\"\n        stroke=\"${color}\"\n        stroke-width=\"${thickness}\"\n        fill=\"${isFilled ? color : \"transparent\"}\"\n      />`;\n        })}</svg>`\n    );\n\n  return (\n    <a\n      href={serializedSVG}\n      onMouseEnter={() => setHover(true)}\n      onMouseLeave={() => setHover(false)}\n      download=\"download.svg\"\n      style={{\n        padding: \"10px\",\n        width: \"180px\",\n        margin: \"10px\",\n        background: hover ? \"#00c853\" : \"#009624\",\n        color: \"#fff\",\n        borderRadius: \"5px\",\n        fontFamily: \"sans-serif\",\n        fontSize: \"24px\",\n        textDecoration: \"none\",\n        display: \"block\",\n        textAlign: \"center\",\n        transition: \"background 0.2s ease-in\",\n      }}\n    >\n      Export to SVG\n    </a>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}